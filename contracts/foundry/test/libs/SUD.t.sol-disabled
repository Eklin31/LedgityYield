// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "../../lib/forge-std/src/Test.sol";
import {SUD} from "../../../src/libs/SUD.sol";

contract Tests is Test {
    // =============================
    // === decimalsOf() function ===

    // =============================
    // === fromAmount() function ===
    function testFuzz_fromAmount_1(uint256 n) public {
        console.log("Should return input times 10^3 (non-overflow cases)");

        // Bound n to non-overflow cases
        n = bound(n, 0, type(uint256).max / 10 ** 3);

        assertEq(SUD.fromAmount(n), n * 10 ** 3);
    }

    function testFuzz_fromAmount_2(uint256 n) public {
        console.log("Should revert on overflow");

        // Bound n to overflow cases
        n = bound(n, type(uint256).max / 10 ** 3 + 1, type(uint256).max);

        vm.expectRevert();
        SUD.fromAmount(n);
    }

    // ===========================
    // === toAmount() function ===
    function testFuzz_toAmount_1(uint256 n) public {
        console.log("Should return input divided 10^3 (non-overflow cases)");

        // Bound n to non-underflow cases
        n = bound(n, 1000, type(uint256).max / 10 ** 3);

        assertEq(SUD.toAmount(n), n / 10 ** 3);
    }

    function testFuzz_toAmount_2(uint256 n) public {
        console.log("Shouldn't revert on underflow, just return 0");

        // Bound n to underflow cases
        n = bound(n, 0, 1000 - 1);

        assertEq(SUD.toAmount(n), 0);
    }

    // ===========================
    // === fromRate() function ===
    function testFuzz_fromRate_1(uint8 decimals, uint256 n) public {
        console.log("Should return given number times 10^decimals when doesn't overflow");

        // Bound decimals to [0, 18]
        decimals = uint8(bound(decimals, 0, 18));

        // Restrict n to non-overflowing values
        n = bound(n, 0, type(uint256).max / (10 ** decimals));

        assertEq(SUD.fromRate(n, decimals), n * 10 ** decimals);
    }

    function testFuzz_fromRate_2(uint8 decimals, uint256 n) public {
        console.log("Should properly overflow on big numbers");

        // Bound decimals to [0, 18]
        decimals = uint8(bound(decimals, 0, 18));

        // Restrict n to overflowing values
        n = bound(n, type(uint256).max / (10 ** decimals), type(uint256).max);
        vm.assume(n > type(uint256).max / (10 ** decimals));

        vm.expectRevert(stdError.arithmeticError);
        SUD.fromRate(n, decimals);
    }

    // =========================
    // === toRate() function ===
    function testFuzz_toRate_1(uint8 decimals, uint256 n) public {
        console.log("Should return given number divided by 10^decimals and never revert");

        // Bound decimals to [0, 18]
        decimals = uint8(bound(decimals, 0, 18));

        assertEq(SUD.toRate(n, decimals), n / 10 ** decimals);
    }

    // ==========================
    // === fromInt() function ===
    function testFuzz_fromInt_1(uint8 decimals, uint256 n) public {
        console.log("Should return given number times 10^decimals+3 when doesn't overflow");

        // Bound decimals to [0, 18]
        decimals = uint8(bound(decimals, 0, 18));

        // Restrict n to non-overflowing values
        n = bound(n, 0, type(uint256).max / 10 ** (decimals + 3));

        assertEq(SUD.fromInt(n, decimals), n * 10 ** (decimals + 3));
    }

    function testFuzz__fromInt_2(uint8 decimals, uint256 n) public {
        console.log("Should properly overflow on big numbers");

        // Bound decimals to [0, 18]
        decimals = uint8(bound(decimals, 0, 18));

        // Restrict n to overflowing values
        n = bound(n, type(uint256).max / 10 ** (decimals + 3) + 1, type(uint256).max);

        vm.expectRevert(stdError.arithmeticError);
        SUD.fromInt(n, decimals);
    }

    // ========================
    // === toInt() function ===
    function testFuzz__toInt_1(uint8 decimals, uint256 n) public {
        console.log("Should return given number divided by 10^decimals and never revert");

        // Bound decimals to [0, 18] and set random invested token decimals
        decimals = uint8(bound(decimals, 0, 18));

        assertEq(SUD.toInt(n, decimals), n / 10 ** (decimals + 3));
    }
}
